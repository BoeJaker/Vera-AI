"""
ESP32 and Microcontroller Management Tools
Enables LLM to write code, flash devices, and communicate with microcontrollers
Supports USB/Serial, WiFi, MQTT, and WebSocket communication
"""

import os
import serial
import serial.tools.list_ports
import subprocess
import json
import time
import threading
import requests
from typing import List, Dict, Any, Optional, Literal, Callable
from pathlib import Path
from pydantic import BaseModel, Field
from queue import Queue
import asyncio
import websockets

# ============================================================================
# INPUT SCHEMAS
# ============================================================================

class ESP32CodeGenerateInput(BaseModel):
    """Input schema for generating ESP32 code."""
    task_description: str = Field(
        ..., 
        description="What the ESP32 should do (e.g., 'monitor WiFi networks and report SSIDs')"
    )
    language: Literal["arduino", "micropython", "esp-idf"] = Field(
        default="arduino",
        description="Programming language/framework"
    )
    communication_method: Literal["serial", "wifi_http", "wifi_websocket", "mqtt"] = Field(
        default="serial",
        description="How to communicate data back to the LLM"
    )
    additional_requirements: Optional[str] = Field(
        default=None,
        description="Additional requirements or constraints"
    )


class ESP32FlashInput(BaseModel):
    """Input schema for flashing ESP32."""
    code_file: str = Field(..., description="Path to code file to flash")
    port: Optional[str] = Field(
        default=None,
        description="Serial port (auto-detect if not specified)"
    )
    board_type: str = Field(
        default="esp32",
        description="Board type (esp32, esp32s2, esp32s3, esp32c3)"
    )
    erase_flash: bool = Field(
        default=False,
        description="Erase flash before uploading"
    )


class SerialCommunicateInput(BaseModel):
    """Input schema for serial communication."""
    port: Optional[str] = Field(
        default=None,
        description="Serial port (auto-detect if not specified)"
    )
    command: Optional[str] = Field(
        default=None,
        description="Command to send to device"
    )
    duration: int = Field(
        default=10,
        description="How long to listen (seconds)"
    )
    baud_rate: int = Field(
        default=115200,
        description="Baud rate for serial communication"
    )


class WiFiDeviceSetupInput(BaseModel):
    """Input schema for WiFi device setup."""
    device_name: str = Field(..., description="Name for this device")
    wifi_ssid: str = Field(..., description="WiFi network SSID")
    wifi_password: str = Field(..., description="WiFi password")
    server_port: int = Field(
        default=80,
        description="Port for HTTP server on device"
    )


class DeviceDataQueryInput(BaseModel):
    """Input schema for querying device data."""
    device_name: Optional[str] = Field(
        default=None,
        description="Device name (if None, query all devices)"
    )
    endpoint: str = Field(
        default="/data",
        description="Endpoint to query"
    )
    timeout: int = Field(
        default=5,
        description="Request timeout in seconds"
    )


class MQTTSetupInput(BaseModel):
    """Input schema for MQTT setup."""
    broker_address: str = Field(
        default="mqtt.eclipseprojects.io",
        description="MQTT broker address"
    )
    topic: str = Field(..., description="MQTT topic to publish/subscribe")
    device_id: str = Field(..., description="Unique device identifier")


# ============================================================================
# ESP32 CODE TEMPLATES
# ============================================================================

class ESP32CodeTemplates:
    """Templates for common ESP32 tasks."""
    
    @staticmethod
    def arduino_serial_template(task_code: str) -> str:
        """Arduino template with serial communication."""
        return f'''
// Auto-generated ESP32 code for serial communication
// Generated by Vera AI

void setup() {{
  Serial.begin(115200);
  delay(1000);
  Serial.println("ESP32 Ready");
  
  // Task-specific setup
  {task_code}
}}

void loop() {{
  // Task-specific loop
  // Check for serial commands
  if (Serial.available() > 0) {{
    String cmd = Serial.readStringUntil('\\n');
    handleCommand(cmd);
  }}
  
  // Your main task logic here
  delay(100);
}}

void handleCommand(String cmd) {{
  cmd.trim();
  
  if (cmd == "STATUS") {{
    Serial.println("OK");
  }} else if (cmd == "RESET") {{
    ESP.restart();
  }} else {{
    processCustomCommand(cmd);
  }}
}}

void processCustomCommand(String cmd) {{
  // Custom command handling
  Serial.println("Unknown command: " + cmd);
}}

void sendData(String key, String value) {{
  // Send data in JSON format over serial
  Serial.println("{{\\\"" + key + "\\\":\\\"" + value + "\\\"}}");
}}
'''
    
    @staticmethod
    def arduino_wifi_http_template(ssid: str, password: str, port: int, task_code: str) -> str:
        """Arduino template with WiFi HTTP server."""
        return f'''
// Auto-generated ESP32 code with WiFi HTTP server
#include <WiFi.h>
#include <WebServer.h>

const char* ssid = "{ssid}";
const char* password = "{password}";

WebServer server({port});

void setup() {{
  Serial.begin(115200);
  
  // Connect to WiFi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  
  while (WiFi.status() != WL_CONNECTED) {{
    delay(500);
    Serial.print(".");
  }}
  
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  
  // Setup HTTP endpoints
  server.on("/", handleRoot);
  server.on("/data", handleData);
  server.on("/command", HTTP_POST, handleCommand);
  server.onNotFound(handleNotFound);
  
  server.begin();
  Serial.println("HTTP server started");
  
  // Task-specific setup
  {task_code}
}}

void loop() {{
  server.handleClient();
  
  // Your main task logic here
  delay(10);
}}

void handleRoot() {{
  String html = "<html><body><h1>ESP32 Device</h1>";
  html += "<p>Status: Running</p>";
  html += "<p><a href='/data'>View Data</a></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}}

void handleData() {{
  // Return data as JSON
  String json = getDataJSON();
  server.send(200, "application/json", json);
}}

void handleCommand() {{
  if (server.hasArg("cmd")) {{
    String cmd = server.arg("cmd");
    Serial.println("Received command: " + cmd);
    
    processCommand(cmd);
    server.send(200, "application/json", "{{\\\"status\\\":\\\"ok\\\"}}");
  }} else {{
    server.send(400, "application/json", "{{\\\"error\\\":\\\"missing cmd\\\"}}");
  }}
}}

void handleNotFound() {{
  server.send(404, "text/plain", "Not Found");
}}

String getDataJSON() {{
  // Override this with your data collection logic
  return "{{\\\"status\\\":\\\"ok\\\",\\\"timestamp\\\":" + String(millis()) + "}}";
}}

void processCommand(String cmd) {{
  // Override this with your command processing logic
  Serial.println("Processing: " + cmd);
}}
'''
    
    @staticmethod
    def arduino_wifi_websocket_template(ssid: str, password: str, task_code: str) -> str:
        """Arduino template with WebSocket server."""
        return f'''
// Auto-generated ESP32 code with WebSocket server
#include <WiFi.h>
#include <WebSocketsServer.h>

const char* ssid = "{ssid}";
const char* password = "{password}";

WebSocketsServer webSocket = WebSocketsServer(81);

void setup() {{
  Serial.begin(115200);
  
  // Connect to WiFi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  
  while (WiFi.status() != WL_CONNECTED) {{
    delay(500);
    Serial.print(".");
  }}
  
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  
  // Start WebSocket server
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);
  Serial.println("WebSocket server started on port 81");
  
  // Task-specific setup
  {task_code}
}}

void loop() {{
  webSocket.loop();
  
  // Your main task logic here
  delay(10);
}}

void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {{
  switch(type) {{
    case WStype_DISCONNECTED:
      Serial.printf("[%u] Disconnected!\\n", num);
      break;
      
    case WStype_CONNECTED:
      {{
        IPAddress ip = webSocket.remoteIP(num);
        Serial.printf("[%u] Connected from %d.%d.%d.%d\\n", num, ip[0], ip[1], ip[2], ip[3]);
      }}
      break;
      
    case WStype_TEXT:
      Serial.printf("[%u] Received: %s\\n", num, payload);
      processWebSocketCommand(num, (char*)payload);
      break;
  }}
}}

void processWebSocketCommand(uint8_t num, String cmd) {{
  // Process commands received via WebSocket
  if (cmd == "STATUS") {{
    sendWebSocketData(num, "{{\\\"status\\\":\\\"ok\\\"}}");
  }} else {{
    // Custom command handling
    Serial.println("Command: " + cmd);
  }}
}}

void sendWebSocketData(uint8_t num, String data) {{
  webSocket.sendTXT(num, data);
}}

void broadcastData(String data) {{
  webSocket.broadcastTXT(data);
}}
'''
    
    @staticmethod
    def arduino_mqtt_template(broker: str, topic: str, device_id: str, task_code: str) -> str:
        """Arduino template with MQTT."""
        return f'''
// Auto-generated ESP32 code with MQTT
#include <WiFi.h>
#include <PubSubClient.h>

const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";
const char* mqtt_server = "{broker}";
const char* device_id = "{device_id}";
const char* topic_pub = "{topic}/data";
const char* topic_sub = "{topic}/command";

WiFiClient espClient;
PubSubClient client(espClient);

void setup() {{
  Serial.begin(115200);
  
  // Connect to WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {{
    delay(500);
    Serial.print(".");
  }}
  Serial.println("\\nWiFi connected");
  
  // Setup MQTT
  client.setServer(mqtt_server, 1883);
  client.setCallback(mqttCallback);
  
  reconnectMQTT();
  
  // Task-specific setup
  {task_code}
}}

void loop() {{
  if (!client.connected()) {{
    reconnectMQTT();
  }}
  client.loop();
  
  // Your main task logic here
  delay(10);
}}

void reconnectMQTT() {{
  while (!client.connected()) {{
    Serial.print("Connecting to MQTT...");
    
    if (client.connect(device_id)) {{
      Serial.println("connected");
      client.subscribe(topic_sub);
    }} else {{
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" retrying in 5 seconds");
      delay(5000);
    }}
  }}
}}

void mqttCallback(char* topic, byte* payload, unsigned int length) {{
  String message = "";
  for (int i = 0; i < length; i++) {{
    message += (char)payload[i];
  }}
  
  Serial.println("MQTT Received: " + message);
  processCommand(message);
}}

void publishData(String data) {{
  client.publish(topic_pub, data.c_str());
}}

void processCommand(String cmd) {{
  // Custom command processing
  Serial.println("Processing: " + cmd);
}}
'''
    
    @staticmethod
    def wifi_scanner_task() -> str:
        """WiFi network scanner task code."""
        return '''
  // WiFi Scanner specific setup
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  Serial.println("WiFi scanner initialized");
  
  void scanAndReport() {
    Serial.println("Scanning networks...");
    int n = WiFi.scanNetworks();
    
    String json = "{\"networks\":[";
    for (int i = 0; i < n; i++) {
      if (i > 0) json += ",";
      json += "{";
      json += "\"ssid\":\"" + WiFi.SSID(i) + "\",";
      json += "\"rssi\":" + String(WiFi.RSSI(i)) + ",";
      json += "\"encryption\":" + String(WiFi.encryptionType(i));
      json += "}";
    }
    json += "]}";
    
    // Send via configured method
    sendData("wifi_scan", json);
  }
  
  // Call scanAndReport() in loop every 10 seconds
'''
    
    @staticmethod
    def sensor_reading_task(sensor_type: str) -> str:
        """Generic sensor reading task."""
        return f'''
  // Sensor reading setup for {sensor_type}
  // Configure your sensor pins and initialization here
  
  void readAndReportSensor() {{
    // Read sensor value
    float value = analogRead(A0); // Adjust for your sensor
    
    String json = "{{";
    json += "\\"sensor\\":\\"{sensor_type}\\",";
    json += "\\"value\\":" + String(value) + ",";
    json += "\\"timestamp\\":" + String(millis());
    json += "}}";
    
    sendData("sensor_reading", json);
  }}
'''


# ============================================================================
# ESP32 DEVICE MANAGER
# ============================================================================

class ESP32DeviceManager:
    """Manages ESP32 devices and communication."""
    
    def __init__(self, agent):
        self.agent = agent
        self.devices = {}  # device_name -> device_info
        self.serial_connections = {}
        self.data_queue = Queue()
        
        # Check for required tools
        self.esptool_available = self._check_esptool()
        self.arduino_cli_available = self._check_arduino_cli()
    
    def _check_esptool(self) -> bool:
        """Check if esptool is available."""
        try:
            subprocess.run(["esptool.py", "version"], 
                         capture_output=True, check=True)
            return True
        except:
            return False
    
    def _check_arduino_cli(self) -> bool:
        """Check if arduino-cli is available."""
        try:
            subprocess.run(["arduino-cli", "version"], 
                         capture_output=True, check=True)
            return True
        except:
            return False
    
    def list_serial_ports(self) -> List[Dict[str, str]]:
        """List available serial ports."""
        ports = []
        for port in serial.tools.list_ports.comports():
            ports.append({
                "device": port.device,
                "description": port.description,
                "hwid": port.hwid
            })
        return ports
    
    def auto_detect_esp32_port(self) -> Optional[str]:
        """Auto-detect ESP32 serial port."""
        for port in serial.tools.list_ports.comports():
            # ESP32 typically shows up as CP2102 or CH340
            if any(chip in port.description.upper() for chip in ["CP2102", "CH340", "UART", "USB-SERIAL"]):
                return port.device
        return None
    
    def generate_esp32_code(self, task_description: str, language: str,
                          communication_method: str,
                          additional_requirements: str = None) -> Dict[str, str]:
        """
        Generate ESP32 code using LLM.
        
        Returns dict with 'code', 'filename', 'instructions'
        """
        # Build prompt for LLM
        prompt = f"""
Generate complete {language} code for an ESP32 to accomplish this task:

Task: {task_description}

Communication Method: {communication_method}

Additional Requirements: {additional_requirements or "None"}

Requirements:
1. Generate complete, production-ready code
2. Include proper error handling
3. Use {communication_method} for data transmission
4. Add clear comments explaining the logic
5. Include setup instructions in comments

Please provide:
1. Complete code
2. Required libraries (if any)
3. Wiring instructions (if applicable)
4. Usage instructions

Format your response as:
CODE:
[your code here]

LIBRARIES:
[list required libraries]

INSTRUCTIONS:
[setup and usage instructions]
"""
        
        # Get response from LLM
        response = self.agent.deep_llm.invoke(prompt)
        
        # Parse response
        code_start = response.find("CODE:") + 5
        libraries_start = response.find("LIBRARIES:")
        instructions_start = response.find("INSTRUCTIONS:")
        
        code = response[code_start:libraries_start].strip() if libraries_start > 0 else response[code_start:].strip()
        libraries = response[libraries_start+10:instructions_start].strip() if instructions_start > 0 else ""
        instructions = response[instructions_start+13:].strip() if instructions_start > 0 else ""
        
        # Determine file extension
        ext = ".ino" if language == "arduino" else ".py" if language == "micropython" else ".c"
        filename = f"esp32_generated_{int(time.time())}{ext}"
        
        return {
            "code": code,
            "filename": filename,
            "libraries": libraries,
            "instructions": instructions,
            "language": language
        }
    
    def save_code_file(self, code: str, filename: str) -> str:
        """Save generated code to file."""
        code_dir = Path("./esp32_projects")
        code_dir.mkdir(exist_ok=True)
        
        filepath = code_dir / filename
        filepath.write_text(code)
        
        return str(filepath)
    
    def flash_esp32(self, code_file: str, port: str = None, 
                   board_type: str = "esp32", erase_flash: bool = False) -> str:
        """
        Flash code to ESP32.
        
        For Arduino code (.ino), compiles and uploads.
        For MicroPython (.py), uses esptool/ampy.
        """
        if not port:
            port = self.auto_detect_esp32_port()
            if not port:
                return "[Error] No ESP32 device detected"
        
        code_path = Path(code_file)
        
        if code_path.suffix == ".ino":
            # Arduino code
            if not self.arduino_cli_available:
                return "[Error] arduino-cli not installed. Install: https://arduino.github.io/arduino-cli/"
            
            return self._flash_arduino(code_file, port, board_type, erase_flash)
        
        elif code_path.suffix == ".py":
            # MicroPython
            if not self.esptool_available:
                return "[Error] esptool not installed. Install: pip install esptool"
            
            return self._flash_micropython(code_file, port, board_type, erase_flash)
        
        else:
            return f"[Error] Unsupported file type: {code_path.suffix}"
    
    def _flash_arduino(self, code_file: str, port: str, board_type: str, erase: bool) -> str:
        """Flash Arduino code to ESP32."""
        try:
            # Create sketch directory
            code_path = Path(code_file)
            sketch_dir = code_path.parent / code_path.stem
            sketch_dir.mkdir(exist_ok=True)
            
            # Copy .ino file to sketch directory
            sketch_file = sketch_dir / code_path.name
            sketch_file.write_text(code_path.read_text())
            
            # Compile
            compile_cmd = [
                "arduino-cli", "compile",
                "--fqbn", f"esp32:esp32:{board_type}",
                str(sketch_dir)
            ]
            
            result = subprocess.run(compile_cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                return f"[Compile Error]\n{result.stderr}"
            
            # Upload
            upload_cmd = [
                "arduino-cli", "upload",
                "--fqbn", f"esp32:esp32:{board_type}",
                "--port", port,
                str(sketch_dir)
            ]
            
            result = subprocess.run(upload_cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                return f"[Upload Error]\n{result.stderr}"
            
            return f"✓ Successfully flashed {code_file} to ESP32 on {port}"
            
        except Exception as e:
            return f"[Error] Flash failed: {str(e)}"
    
    def _flash_micropython(self, code_file: str, port: str, board_type: str, erase: bool) -> str:
        """Flash MicroPython code to ESP32."""
        try:
            if erase:
                # Erase flash
                erase_cmd = ["esptool.py", "--port", port, "erase_flash"]
                subprocess.run(erase_cmd, check=True)
            
            # Upload file using ampy
            upload_cmd = ["ampy", "--port", port, "put", code_file, "main.py"]
            result = subprocess.run(upload_cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                return f"[Upload Error]\n{result.stderr}"
            
            return f"✓ Successfully uploaded {code_file} to ESP32 on {port}"
            
        except Exception as e:
            return f"[Error] Flash failed: {str(e)}"
    
    def serial_communicate(self, port: str = None, command: str = None,
                          duration: int = 10, baud_rate: int = 115200) -> str:
        """
        Communicate with ESP32 over serial.
        
        Can send commands and listen for responses.
        """
        if not port:
            port = self.auto_detect_esp32_port()
            if not port:
                return "[Error] No device detected"
        
        try:
            ser = serial.Serial(port, baud_rate, timeout=1)
            time.sleep(2)  # Wait for connection
            
            output = [f"Connected to {port} at {baud_rate} baud\n"]
            
            # Send command if provided
            if command:
                ser.write(f"{command}\n".encode())
                output.append(f"Sent: {command}\n")
            
            # Listen for duration
            start_time = time.time()
            while time.time() - start_time < duration:
                if ser.in_waiting:
                    line = ser.readline().decode('utf-8', errors='ignore').strip()
                    if line:
                        output.append(line)
                        
                        # Try to parse as JSON and store
                        try:
                            data = json.loads(line)
                            self.data_queue.put(data)
                        except:
                            pass
                
                time.sleep(0.1)
            
            ser.close()
            
            return "\n".join(output)
            
        except Exception as e:
            return f"[Error] Serial communication failed: {str(e)}"
    
    def start_serial_listener(self, port: str = None, baud_rate: int = 115200,
                            callback: Callable = None):
        """
        Start background thread to continuously listen on serial.
        
        Stores received data in queue and optionally calls callback.
        """
        if not port:
            port = self.auto_detect_esp32_port()
            if not port:
                return False
        
        def listen():
            try:
                ser = serial.Serial(port, baud_rate, timeout=1)
                
                while True:
                    if ser.in_waiting:
                        line = ser.readline().decode('utf-8', errors='ignore').strip()
                        if line:
                            # Store in queue
                            self.data_queue.put({"raw": line, "timestamp": time.time()})
                            
                            # Try JSON parsing
                            try:
                                data = json.loads(line)
                                self.data_queue.put({"json": data, "timestamp": time.time()})
                                
                                if callback:
                                    callback(data)
                            except:
                                pass
                    
                    time.sleep(0.1)
            except:
                pass
        
        thread = threading.Thread(target=listen, daemon=True)
        thread.start()
        
        return True
    
    def register_wifi_device(self, device_name: str, ip_address: str, 
                           port: int = 80):
        """Register a WiFi-enabled ESP32 device."""
        self.devices[device_name] = {
            "type": "wifi",
            "ip": ip_address,
            "port": port,
            "base_url": f"http://{ip_address}:{port}"
        }
        
        # Store in memory
        self.agent.mem.add_session_memory(
            self.agent.sess.id,
            device_name,
            "esp32_device",
            metadata={"ip": ip_address, "port": port}
        )
    
    def query_wifi_device(self, device_name: str, endpoint: str = "/data",
                         timeout: int = 5) -> Dict:
        """Query a WiFi device via HTTP."""
        if device_name not in self.devices:
            return {"error": f"Device {device_name} not registered"}
        
        device = self.devices[device_name]
        url = f"{device['base_url']}{endpoint}"
        
        try:
            response = requests.get(url, timeout=timeout)
            response.raise_for_status()
            
            # Try to parse JSON
            try:
                return response.json()
            except:
                return {"data": response.text}
        
        except Exception as e:
            return {"error": str(e)}
    
    def send_command_to_device(self, device_name: str, command: str) -> Dict:
        """Send command to WiFi device."""
        if device_name not in self.devices:
            return {"error": f"Device {device_name} not registered"}
        
        device = self.devices[device_name]
        url = f"{device['base_url']}/command"
        
        try:
            response = requests.post(url, data={"cmd": command}, timeout=5)
            response.raise_for_status()
            
            return response.json()
        
        except Exception as e:
            return {"error": str(e)}


# ============================================================================
# ESP32 TOOLS CLASS
# ============================================================================

class ESP32Tools:
    """Tools for ESP32/microcontroller development."""
    
    def __init__(self, agent):
        self.agent = agent
        self.manager = ESP32DeviceManager(agent)
        self.templates = ESP32CodeTemplates()
    
    def generate_esp32_code(self, task_description: str, language: str = "arduino",
                           communication_method: str = "serial",
                           additional_requirements: str = None) -> str:
        """
        Generate ESP32 code for a specific task.
        
        The LLM designs complete ESP32 programs based on task description.
        
        Args:
            task_description: What the ESP32 should do
            language: arduino, micropython, or esp-idf
            communication_method: serial, wifi_http, wifi_websocket, or mqtt
            additional_requirements: Additional constraints
        
        Examples:
            "Monitor WiFi networks and report SSIDs with signal strength every 10 seconds"
            "Read temperature from DHT22 sensor and send data over MQTT"
            "Create a web server that controls 3 LEDs via HTTP endpoints"
            "Listen for button presses and send events over WebSocket"
        
        Returns generated code, filename, and instructions.
        """
        try:
            result = self.manager.generate_esp32_code(
                task_description,
                language,
                communication_method,
                additional_requirements
            )
            
            # Save code file
            filepath = self.manager.save_code_file(result["code"], result["filename"])
            
            output = [
                f"✓ Generated ESP32 code: {result['filename']}",
                f"Language: {language}",
                f"Communication: {communication_method}",
                f"File saved: {filepath}",
                "",
                "Required Libraries:",
                result.get("libraries", "None"),
                "",
                "Setup Instructions:",
                result.get("instructions", "Flash to ESP32 and monitor serial output"),
                "",
                "Code Preview:",
                "=" * 60,
                result["code"][:500] + "..." if len(result["code"]) > 500 else result["code"]
            ]
            
            # Store in memory
            self.agent.mem.add_session_memory(
                self.agent.sess.id,
                filepath,
                "esp32_code_generated",
                metadata={
                    "task": task_description,
                    "language": language,
                    "communication": communication_method
                }
            )
            
            return "\n".join(output)
            
        except Exception as e:
            return f"[Error] Code generation failed: {str(e)}"
    
    def flash_esp32_device(self, code_file: str, port: str = None,
                          board_type: str = "esp32", erase_flash: bool = False) -> str:
        """
        Flash code to ESP32 device.
        
        Automatically detects device if port not specified.
        Compiles Arduino sketches or uploads MicroPython files.
        
        Args:
            code_file: Path to code file (.ino or .py)
            port: Serial port (auto-detect if None)
            board_type: esp32, esp32s2, esp32s3, esp32c3
            erase_flash: Erase flash before uploading
        
        Example:
            flash_esp32_device("esp32_generated_123.ino")
        """
        return self.manager.flash_esp32(code_file, port, board_type, erase_flash)
    
    def communicate_serial(self, port: str = None, command: str = None,
                          duration: int = 10, baud_rate: int = 115200) -> str:
        """
        Communicate with ESP32 over USB/Serial.
        
        Send commands and receive data from the device.
        
        Args:
            port: Serial port (auto-detect if None)
            command: Command to send to device
            duration: How long to listen for responses (seconds)
            baud_rate: Serial baud rate
        
        Common commands:
            - STATUS: Check device status
            - RESET: Reset the device
            - Custom commands defined in your code
        
        Example:
            communicate_serial(command="STATUS", duration=5)
        """
        return self.manager.serial_communicate(port, command, duration, baud_rate)
    
    def setup_wifi_device(self, device_name: str, wifi_ssid: str,
                         wifi_password: str, server_port: int = 80) -> str:
        """
        Generate code for WiFi-enabled ESP32 with HTTP server.
        
        Creates a device that connects to WiFi and runs an HTTP server
        for remote communication.
        
        Args:
            device_name: Unique name for this device
            wifi_ssid: WiFi network name
            wifi_password: WiFi password
            server_port: HTTP server port (default: 80)
        
        The device will expose endpoints:
            - GET / : Status page
            - GET /data : Get device data as JSON
            - POST /command : Send commands to device
        
        Example:
            setup_wifi_device(
                device_name="workshop_monitor",
                wifi_ssid="MyNetwork",
                wifi_password="mypassword"
            )
        """
        try:
            # Generate WiFi HTTP server code
            task_code = "// Add your task-specific setup here"
            code = self.templates.arduino_wifi_http_template(
                wifi_ssid, wifi_password, server_port, task_code
            )
            
            # Save code
            filename = f"{device_name}_wifi.ino"
            filepath = self.manager.save_code_file(code, filename)
            
            output = [
                f"✓ Generated WiFi device code: {filename}",
                f"Device name: {device_name}",
                f"WiFi: {wifi_ssid}",
                f"Server port: {server_port}",
                f"File saved: {filepath}",
                "",
                "Next steps:",
                "1. Flash this code to your ESP32",
                "2. Device will connect to WiFi and print its IP address",
                "3. Register device with: register_wifi_device(name, ip_address)",
                "4. Query device with: query_device_data(name)"
            ]
            
            return "\n".join(output)
            
        except Exception as e:
            return f"[Error] WiFi setup failed: {str(e)}"
    
    def list_serial_devices(self) -> str:
        """
        List all available serial ports.
        
        Helps identify which port your ESP32 is connected to.
        """
        ports = self.manager.list_serial_ports()
        
        if not ports:
            return "No serial devices found"
        
        output = ["Available Serial Ports:\n"]
        
        for port in ports:
            output.append(f"Device: {port['device']}")
            output.append(f"  Description: {port['description']}")
            output.append(f"  Hardware ID: {port['hwid']}")
            output.append("")
        
        return "\n".join(output)
    
    def register_wifi_device(self, device_name: str, ip_address: str,
                            port: int = 80) -> str:
        """
        Register a WiFi-enabled ESP32 for easy access.
        
        After flashing WiFi code to ESP32, use this to register it.
        
        Args:
            device_name: Unique name for device
            ip_address: Device IP address (printed on serial after connection)
            port: HTTP server port (default: 80)
        
        Example:
            register_wifi_device("workshop_monitor", "192.168.1.100")
        """
        self.manager.register_wifi_device(device_name, ip_address, port)
        
        return f"✓ Registered WiFi device: {device_name}\nIP: {ip_address}:{port}\nBase URL: http://{ip_address}:{port}"
    
    def query_device_data(self, device_name: str = None, endpoint: str = "/data",
                         timeout: int = 5) -> str:
        """
        Query data from a registered WiFi device.
        
        Retrieves data from ESP32 over HTTP.
        
        Args:
            device_name: Name of registered device
            endpoint: API endpoint to query
            timeout: Request timeout
        
        Example:
            query_device_data("workshop_monitor", "/data")
        """
        if not device_name:
            # List all devices
            if not self.manager.devices:
                return "No devices registered"
            
            output = ["Registered Devices:\n"]
            for name, info in self.manager.devices.items():
                output.append(f"{name}: {info['base_url']}")
            return "\n".join(output)
        
        result = self.manager.query_wifi_device(device_name, endpoint, timeout)
        
        if "error" in result:
            return f"[Error] {result['error']}"
        
        return json.dumps(result, indent=2)
    
    def send_device_command(self, device_name: str, command: str) -> str:
        """
        Send command to a WiFi device.
        
        Controls the ESP32 remotely via HTTP.
        
        Args:
            device_name: Name of registered device
            command: Command to send
        
        Example:
            send_device_command("workshop_monitor", "START_SCAN")
        """
        result = self.manager.send_command_to_device(device_name, command)
        
        if "error" in result:
            return f"[Error] {result['error']}"
        
        return json.dumps(result, indent=2)
    
    def start_continuous_monitoring(self, port: str = None, baud_rate: int = 115200) -> str:
        """
        Start continuous background monitoring of serial data.
        
        Runs in background thread, collecting data from ESP32.
        Data is queued and can be accessed later.
        
        Args:
            port: Serial port (auto-detect if None)
            baud_rate: Serial baud rate
        
        Example:
            start_continuous_monitoring()
        """
        success = self.manager.start_serial_listener(port, baud_rate)
        
        if success:
            return f"✓ Started continuous monitoring on {port or 'auto-detected port'}\nData will be collected in background"
        else:
            return "[Error] Failed to start monitoring - no device detected"


# ============================================================================
# ADD TO TOOLLOADER FUNCTION
# ============================================================================

def add_esp32_tools(tool_list: List, agent):
    """
    Add ESP32 and microcontroller development tools.
    
    Enables LLM to:
    - Generate ESP32 code for specific tasks
    - Flash code to devices
    - Communicate over Serial/USB
    - Setup WiFi devices with HTTP servers
    - Query and control devices remotely
    - Monitor data continuously
    
    Supports Arduino, MicroPython, and ESP-IDF.
    Communication via Serial, HTTP, WebSocket, and MQTT.
    
    Requirements:
    - esptool.py: pip install esptool
    - arduino-cli: https://arduino.github.io/arduino-cli/
    - pyserial: pip install pyserial
    
    Call in ToolLoader:
        add_esp32_tools(tool_list, agent)
    """
    
    esp32_tools = ESP32Tools(agent)
    
    tool_list.extend([
        StructuredTool.from_function(
            func=esp32_tools.generate_esp32_code,
            name="generate_esp32_code",
            description=(
                "Generate complete ESP32 code for a specific task. "
                "LLM designs the program based on task description. "
                "Supports Arduino, MicroPython, various communication methods. "
                "Example: 'Monitor WiFi networks and report SSIDs'"
            ),
            args_schema=ESP32CodeGenerateInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.flash_esp32_device,
            name="flash_esp32_device",
            description=(
                "Flash code to ESP32 device via USB. "
                "Auto-detects device, compiles Arduino sketches. "
                "Uploads and runs the code on the microcontroller."
            ),
            args_schema=ESP32FlashInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.communicate_serial,
            name="communicate_serial",
            description=(
                "Communicate with ESP32 over Serial/USB. "
                "Send commands and receive data from device. "
                "Use for reading sensor data, controlling device, debugging."
            ),
            args_schema=SerialCommunicateInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.setup_wifi_device,
            name="setup_wifi_device",
            description=(
                "Generate WiFi-enabled ESP32 code with HTTP server. "
                "Device connects to WiFi and exposes REST API. "
                "Enables remote control and data collection."
            ),
            args_schema=WiFiDeviceSetupInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.list_serial_devices,
            name="list_serial_devices",
            description=(
                "List all serial ports. "
                "Helps identify which port ESP32 is connected to. "
                "Shows device descriptions and hardware IDs."
            ),
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.register_wifi_device,
            name="register_wifi_device",
            description=(
                "Register WiFi-enabled ESP32 for easy access. "
                "After flashing WiFi code, register device with IP. "
                "Enables querying and controlling via device name."
            ),
            args_schema=WiFiDeviceSetupInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.query_device_data,
            name="query_device_data",
            description=(
                "Query data from registered WiFi device. "
                "Get sensor readings, status, or any data over HTTP. "
                "Returns JSON data from device."
            ),
            args_schema=DeviceDataQueryInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.send_device_command,
            name="send_device_command",
            description=(
                "Send command to WiFi device. "
                "Control ESP32 remotely: start/stop tasks, configure settings. "
                "Works with registered WiFi devices."
            ),
            args_schema=DeviceDataQueryInput
        ),
        
        StructuredTool.from_function(
            func=esp32_tools.start_continuous_monitoring,
            name="start_continuous_monitoring",
            description=(
                "Start background monitoring of serial data. "
                "Continuously collects data from ESP32 in background thread. "
                "Useful for long-running data collection."
            ),
            args_schema=SerialCommunicateInput
        ),
    ])
    
    return tool_list


# Required dependencies (add to requirements.txt):
# pyserial>=3.5
# requests>=2.31.0
# esptool  # Install: pip install esptool
# adafruit-ampy  # For MicroPython: pip install adafruit-ampy