fast_llm: Query fast LLM for quick tasks: creative writing, text review, summarization. Fast but less accurate.
deep_llm: Query deep LLM for complex reasoning and detailed analysis. Slower but more accurate.
read_file: Read contents of a text file. Provide full file path.
write_file: Write content to a file. Creates directories if needed. Overwrites existing files.
list_directory: List directory contents with file sizes and types.
search_files: Search for files matching a pattern recursively. Supports glob and regex patterns.
python: Execute Python code. Use print() for output. Supports both expressions and statements.
bash: Execute bash command. Returns command output. Use with caution.
web_search: Advanced web search using Playwright for robustness.Supports multiple search engines with automatic fallback.
news_search: Search recent news using DuckDuckGo News. Best for current events.
web_search_deep: Comprehensive web search with full page scraping. Use for in-depth information.
http_request: Make HTTP requests to APIs. Supports GET, POST, PUT, DELETE methods.
sqlite_query: Execute SQLite queries. Supports SELECT, INSERT, UPDATE, DELETE.
git: Execute git commands: status, log, diff, branch, add, commit, push, pull.
get_time: Get current date and time in specified timezone.
time_delta: Calculate time difference between two dates or from date to now.
count_tokens: Estimate token count for text. Useful for managing context windows.
regex_search: Search text using regular expressions with optional flags.
text_stats: Generate comprehensive statistics about text (word count, sentences, etc).
parse_json: Parse and validate JSON, returning formatted output.
csv_to_json: Convert CSV file to JSON format.
hash_text: Generate cryptographic hash (md5, sha1, sha256, sha512) of text.
system_info: Get system information including OS, Python version, etc.
get_env: Get environment variable value.
list_env: List all environment variables (sanitized).
search_memory: Search agent's long-term memory for relevant past information.
list_modules: List all currently loaded Python modules in the runtime.
discover_tools: Discover and list available custom tools in the tools directory. Shows functions and their parameters. Tools with ðŸ”§ are auto-loaded via @tool decorator.
call_custom_tool: Call a function from a custom tool file. Provide tool name, function name, and arguments. Use for tools not auto-loaded or for dynamic execution.
list_tool_functions: List all functions in a specific custom tool file with their parameters. Shows docstrings and whether functions are auto-loadable.
reload_tools: Reload all custom tool modules. Use after editing tool files to pick up changes without restarting.
ssh_connect: Connect to SSH server. Returns connection ID for other SSH operations.
ssh_execute: Execute command on remote SSH server. Returns command output.
ssh_ls: List contents of remote directory via SFTP.
ssh_read: Read contents of remote file via SFTP.
ssh_download: Download file from remote server via SFTP.
ssh_upload: Upload file to remote server via SFTP.
ssh_disconnect: Close SSH connection and clean up resources.
postgres_connect: Connect to PostgreSQL database. Returns connection ID for queries.
postgres_query: Execute SQL query on PostgreSQL. Supports SELECT, INSERT, UPDATE, DELETE with parameterized queries.
postgres_tables: List all tables in a PostgreSQL schema with sizes.
postgres_describe: Get detailed table structure including columns, types, constraints.
postgres_schemas: List all schemas in PostgreSQL database.
postgres_disconnect: Close PostgreSQL connection.
neo4j_connect: Connect to Neo4j graph database. Returns connection ID for queries.
neo4j_query: Execute Cypher query on Neo4j. Supports all Cypher operations with parameterized queries.
neo4j_create_node: Create a node in Neo4j with label and properties.
neo4j_create_rel: Create relationship between two nodes in Neo4j.
neo4j_find: Search for nodes in Neo4j by label and optional property.
neo4j_schema: Get Neo4j database schema including labels, relationships, and properties.
neo4j_stats: Get Neo4j database statistics including counts and distributions.
neo4j_disconnect: Close Neo4j connection.
check_docker_status: Check if Docker is installed and running. Provides diagnostics and troubleshooting steps if Docker is unavailable.
generate_code: Generate code for ANY task in ANY language. LLM writes complete, production-ready code based on description. Supports scripts, functions, classes, full modules. Example: 'Parse CSV and generate statistics in Python'
execute_code: Execute code and get results. Runs code in sandbox (Docker) or locally. Returns stdout, stderr, exit status. Use to test generated code or run scripts.
create_code_template: Create reusable code template with placeholders. Templates use {{PLACEHOLDER}} syntax. Save patterns for repeated use. Example: API endpoint template, test template, etc.
use_code_template: Generate code from template by filling placeholders. Quick way to create code from saved patterns. Optionally save generated code to file.
list_code_templates: List available code templates. Filter by language or tags. Shows what templates are available for reuse.
refactor_code: Refactor code to improve it. LLM analyzes and rewrites code for performance, readability, etc. Examples: 'optimize performance', 'improve readability', 'add error handling'
debug_code: Debug code and fix bugs. LLM analyzes buggy code and provides fixes. Provide error message and expected behavior for best results.
scaffold_project: Generate complete project structure. Creates directories, configs, example code, tests, CI/CD. Professional project setup in seconds. Types: python-package, web-app, api-service, cli-tool, etc.
register_microcontroller: Register a microcontroller device for control. After programming device, register it here. Supports Serial/USB, WiFi HTTP, WebSocket, MQTT. Makes device available for commands and data streaming.
send_device_command: Send command to microcontroller and get response. Real-time control via Serial or WiFi. Examples: LED_ON, READ_SENSOR, START_SCAN, etc. Can use registered device name or direct port.
stream_device_data: Stream data from microcontroller in real-time. Continuously collect sensor readings, events, etc. Data stored in database, optionally exported to file. Can run for specific duration or continuously.
stop_device_stream: Stop continuous data streaming from device. Use after starting continuous stream (duration=0).
list_microcontrollers: List all registered microcontroller devices. Shows connection status, streaming status, metadata. Quick overview of all connected devices.
query_device_data: Query historical data collected from microcontrollers. Retrieve sensor readings, events from database. Filter by device, time range, limit. Analyze collected data.
bulk_device_command: Send same command to multiple devices at once. Efficient control of device fleets. Can run sequentially or in parallel.
get_device_status: Get detailed status of a microcontroller device. Shows connection state, streaming state, data stats. Troubleshoot device issues.
write_versioned_file: Write a file with automatic versioning. Creates compressed diff, records metadata. Easy to rollback later.
read_versioned_file: Read current or historical version of a file.
query_file_history: View version history log with timestamps, reasons, agents.
view_file_diff: View diff between versions. See exactly what changed.
get_version_stats: Get versioning system statistics and storage usage.
undo_last_change: FASTEST WAY TO UNDO: Instantly reverts last change to a file. Use when you made a mistake and want to quickly undo it. Example: undo_last_change('config.json')
quick_rollback: Quick rollback: Go back N versions. steps_back=1 undoes last change, steps_back=3 goes back 3 versions. Simple and intuitive. Example: quick_rollback('file.py', 2)
time_based_rollback: Rollback to how file was at specific time. Supports natural language: 'yesterday', '2 hours ago', '2024-01-15'. Example: time_based_rollback('config.json', 'yesterday')
session_rollback: Rollback all changes from a session. Undo everything you did in current or specific session. Example: session_rollback() undoes all current session changes
bulk_rollback: Rollback multiple files at once. Efficient for rolling back related changes across many files. Example: bulk_rollback(['file1.py', 'file2.py', 'config.json'])
preview_rollback: Preview rollback WITHOUT making changes. See what would change before actually rolling back. Safe way to check before undoing. Example: preview_rollback('config.json')
tag_based_rollback: Rollback files by tags. Undo all changes with specific tags after a timestamp. Example: tag_based_rollback(['experiment'], 'yesterday')
babelfish: Universal multi-protocol communication tool. Supports HTTP/HTTPS, WebSocket, MQTT, TCP, UDP, SMTP. Enables persistent connections with handles, pub/sub messaging, socket servers, email sending, and more. Returns JSON: {ok: bool, data: any, error: str}
babelfish_handles: Manage Babelfish connection handles. List active connections, read queued messages from persistent connections (WebSocket, MQTT, TCP/UDP listeners), or close handles. Essential for working with bidirectional protocols.
webserver: Control a dynamic FastAPI web server. Start server, mount static directories, create dynamic endpoints (JSON, text, file, Python handlers), remove routes, list routes. Useful for creating temporary APIs, serving files, or testing. Server runs in background thread.
http3_request: Make HTTP/3 request over QUIC protocol. Faster than HTTP/2, better multiplexing, 0-RTT connection. Ideal for modern APIs and mobile networks.
webrtc_connect: Establish WebRTC DataChannel for peer-to-peer communication. Supports STUN/TURN for NAT traversal, encrypted channels, low-latency real-time data transfer. Requires signaling setup.
orchestrator_start: Start the task orchestrator with configurable worker pools. Initialize distributed task execution system with LLM, Whisper, Tool, ML, Background, and General workers. Supports Redis pub/sub and CPU-aware throttling. Returns status and configuration.
orchestrator_stop: Stop the task orchestrator gracefully. Shuts down all worker pools after completing running tasks. No new tasks accepted after shutdown begins.
orchestrator_submit_task: Submit a task for execution through the orchestrator. Tasks are queued by priority and executed by appropriate workers. Supports both regular and streaming (generator) tasks. Returns task ID for tracking. Example: submit_task('llm.generate', kwargs={'prompt': 'Hello'})
orchestrator_wait_task: Wait for a task to complete and retrieve results. Blocks until task finishes or timeout. Set stream=True to stream incremental results from generator tasks. Returns task result or error. Example: wait_for_task(task_id='abc123', stream=True)
orchestrator_stream_task: Stream results from a task as they arrive. Convenience wrapper for streaming tasks (LLM generation, etc.). Works for both streaming and non-streaming tasks. Example: stream_task(task_id='abc123')
orchestrator_stats: Get comprehensive orchestrator statistics. Shows running status, queue sizes, worker pool info, per-worker stats (tasks completed/failed, CPU usage), and recent task history. Essential for monitoring.
orchestrator_scale: Scale a worker pool dynamically while running. Add or remove workers for specific task types. Scaling is graceful - running tasks complete before removal. Example: scale_workers('llm', 8) for heavy LLM load
orchestrator_list_tasks: List all registered tasks in the task registry. Shows tasks that can be submitted, with metadata like type, priority, duration, GPU requirements. Filter by task type or proactive focus flag. Example: list_registered_tasks(task_type='llm')
orchestrator_monitor: Monitor orchestrator events for debugging and analysis. Subscribe to channels: task.started, task.completed, task.failed, focus.changed. Collects events for specified duration. Example: monitor_events('task.completed', duration=30.0)
orchestrator_task_info: Get detailed information about a specific task. Shows status, execution details, worker info, duration, errors. Example: get_task_info(task_id='abc123')
orchestrator_clear_history: Clear the local task history. Removes tracked submissions from memory. Does not affect actual task execution.
search_memory: Search your knowledge graph using semantic or graph queries. Recall information, find related concepts, explore what you know.
inspect_entity: Deep inspection of a specific entity. See all properties, connections, and context for any entity in your knowledge graph.
traverse_graph: Traverse the knowledge graph from a starting point. Follow chains of relationships and discover how concepts are linked.
find_patterns: Discover patterns in your knowledge: clusters, frequent connections, temporal patterns, or co-occurring entities.
generate_insights: Generate insights about knowledge patterns: unexpected connections, trends, contradictions, or gaps in knowledge.
add_note: Add a note, insight, observation, question, or hypothesis to your knowledge graph. Link to relevant entities.
annotate_entity: Add or update properties on existing entities. Enrich entities with observations, classifications, or metadata.
link_entities: Create relationships between entities. Connect concepts, indicate implications, note contradictions, or establish semantic links.
consolidate_memory: Consolidate session memory into long-term knowledge. Summarize, promote important entities, or cluster related concepts.
query_graph: Query the knowledge graph using natural language. Ask complex questions about graph structure or find specific entities.
discover_multihop_paths: Discover multi-hop paths between entities in knowledge graph. Finds direct and indirect relationships through intermediaries. Use to understand how concepts are connected through reasoning chains.
discover_hidden_connections: Discover hidden connections using semantic, structural, or temporal analysis. Finds non-obvious relationships and implicit connections. Use to bridge knowledge silos and find unexpected patterns.
analyze_temporal_patterns: Analyze temporal patterns in knowledge evolution. Tracks how concepts change over time, activity patterns, and trends. Use to understand learning patterns and detect focus shifts.
detect_emergent_patterns: Detect emergent patterns and weak signals in knowledge. Identifies emerging clusters, novel associations, and early trends. Use to spot emerging interests and creative connections.
cross_domain_insights: Generate insights by comparing different knowledge domains. Discovers analogies, knowledge transfers, contradictions, and synergies. Use to bridge different areas and find creative applications.
detect_anomalies: Detect anomalies and contradictions in knowledge. Finds conflicting information, outliers, and inconsistencies. Use to maintain knowledge quality and consistency.
analyze_knowledge_gaps: Identify gaps in knowledge about a topic. Finds missing entities, weak connections, and incomplete attributes. Use to guide learning priorities and improve coverage.
osint_cve_search: Search CVE database for vulnerabilities. Find CVEs by ID, product name, or vendor. Returns CVSS scores, descriptions, and references. Example: search_cve('log4j', severity='CRITICAL')
osint_subdomain_enum: Enumerate subdomains for a target domain. Methods: passive (safe, uses CT logs), bruteforce (DNS queries), hybrid. IMPORTANT: Only use on domains you have permission to test. Example: enumerate_subdomains('example.com', method='passive')
osint_social_scan: Scan social media platforms for username. Checks GitHub, Twitter, LinkedIn, Instagram, Reddit, YouTube, and more. Returns profile existence and URLs. Example: scan_social_profiles('johndoe')
scan_network: Scan network for hosts, ports, and services. Supports CIDR ranges, individual IPs, and hostnames. Three scan types: 'quick' (fast host discovery), 'normal' (standard port scan), 'intensive' (OS detection + scripts). Results stored in graph memory.
scan_services: Detailed service detection and fingerprinting on a target. Identifies service versions, products, banners, and automatically maps services to known CVE vulnerabilities. Essential for vulnerability assessment.
enumerate_dns: Comprehensive DNS reconnaissance for a domain. Gathers A, NS, MX, TXT records, WHOIS data, and performs subdomain enumeration. Optionally attempts zone transfer (AXFR). Results organized in graph with domain as central node.
detect_web_technologies: Identify technologies and frameworks used by a website. Detects CMS systems, JavaScript frameworks, web servers, analytics, CDNs. Automatically maps detected technologies to known CVEs for vulnerability assessment.
search_cves: Search National Vulnerability Database for CVEs affecting a product. Returns CVE IDs, CVSS scores, severity ratings, and detailed descriptions. Essential for vulnerability assessment and patch management.
analyze_ssl: Analyze SSL/TLS certificate and security configuration. Checks certificate validity, expiration, issuer, protocol versions, cipher suites, and identifies common SSL/TLS vulnerabilities. Essential for web security assessment.
export_scan_results: Export OSINT scan results to file. Formats: 'json' (structured data) or 'markdown' (human-readable report). Use scan ID from previous scan output.
discover_hosts: HOST DISCOVERY ONLY. Find live hosts from targets (IP/CIDR/range/hostname). ONLY creates nodes for reachable hosts. Fast parallel checking. Use when you only need to know which hosts are up.
scan_ports: PORT SCANNING ONLY. Scan ports on target hosts. Can use previously discovered hosts or scan new targets. Creates port nodes for open ports only. Fast multi-threaded scanning. Use when you need to find open ports on known hosts.
detect_services: SERVICE DETECTION ONLY. Identify services on discovered ports. Grabs banners, detects versions, identifies service types. Creates service nodes with version info. Use after port scanning to identify what's running.
scan_vulnerabilities: VULNERABILITY SCANNING ONLY. Look up CVEs for discovered services. Queries NVD database, filters by severity, creates CVE nodes. Use after service detection to find known vulnerabilities. Rate-limited to avoid API throttling.
comprehensive_network_scan: FULL COMPREHENSIVE SCAN. Runs all scan phases in sequence: 1) Host discovery, 2) Port scanning, 3) Service detection, 4) CVE lookup. ONLY creates nodes for live/reachable entities. Modes: 'quick' (common ports), 'standard' (1-1000), 'full' (all ports). Creates complete network topology map. Use for thorough network assessment.
mcp_call: Call a tool on an MCP server (filesystem, github, postgres, slack, etc).
mcp_list_tools: List all available tools from an MCP server.
scheduling_assistant: Run the executive scheduling assistant. Access to calendars, todos, scheduling apps. Input: query string.
click_element: Click on an element with the given CSS selector
navigate_browser: Navigate a browser to the specified URL
previous_webpage: Navigate back to the previous page in the browser history
extract_text: Extract all the text on the current webpage
extract_hyperlinks: Extract all hyperlinks on the current webpage
get_elements: Retrieve elements in the current web page matching the given CSS selector
current_webpage: Returns the URL of the current page
