<!DOCTYPE html>
<html> 
<head>
    <meta charset="utf-8">
    <style>
        body { background: #0f1419; margin: 0; padding: 0; }
        
        /* Search Bar */
        .search-container {
            position: fixed; bottom: 20px; left: 10px; z-index: 2000;
            background: #1a1f2e; border: 2px solid #3b82f6; border-radius: 8px;
            padding: 8px 12px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);
            display: flex; flex-direction: column; gap: 8px; max-width: 300px;
        }
        .search-input-row {
            display: flex; align-items: center; gap: 8px;
        }
        .search-results {
            max-height: 300px; overflow-y: auto; display: none;
            background: #0f172a; border-radius: 6px; padding: 4px;
        }
        .search-result-item {
            padding: 8px; margin: 2px 0; background: #1e293b; border-radius: 4px;
            cursor: pointer; transition: all 0.2s; font-size: 12px; color: #e2e8f0;
            border-left: 3px solid #3b82f6;
        }
        .search-result-item:hover {
            background: #334155; transform: translateX(2px);
        }
        .search-result-name {
            font-weight: bold; color: #60a5fa; margin-bottom: 2px;
        }
        .search-result-labels {
            font-size: 10px; color: #94a3b8;
        }
        .search-container input {
            background: #0f172a; border: 1px solid #334155; color: #e2e8f0;
            padding: 6px 12px; border-radius: 6px; font-size: 13px; width: 200px;
            outline: none; flex: 1;
        }
        .search-container input:focus {
            border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.2);
        }
        .search-container button {
            background: #3b82f6; color: white; border: none; padding: 6px 12px;
            border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;
            transition: all 0.2s;
        }
        .search-container button:hover {
            background: #2563eb; transform: translateY(-1px);
        }
        
        /* Context Menu */
        .context-menu {
            position: fixed; background: #1a1f2e; border: 2px solid #3b82f6;
            border-radius: 8px; padding: 8px 0; min-width: 200px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5); z-index: 3000;
            display: none; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .context-menu-item {
            padding: 10px 16px; color: #e2e8f0; cursor: pointer;
            transition: all 0.2s; font-size: 13px; display: flex;
            align-items: center; gap: 10px;
        }
        .context-menu-item:hover {
            background: #334155; color: #3b82f6;
        }
        .context-menu-item .icon {
            font-size: 16px; width: 20px; text-align: center;
        }
        .context-menu-divider {
            height: 1px; background: #334155; margin: 4px 0;
        }
        
        /* Enhanced Tooltip */
        .vis-tooltip {
            background: #1a1f2e !important;
            border: 2px solid #3b82f6 !important;
            border-radius: 8px !important;
            padding: 12px !important;
            color: #e2e8f0 !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
            font-size: 13px !important;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5), 0 0 0 1px rgba(59,130,246,0.2) !important;
            max-width: 350px !important;
            line-height: 1.5 !important;
        }
        .tooltip-title {
            font-weight: bold; color: #60a5fa; margin-bottom: 8px;
            font-size: 14px; border-bottom: 1px solid #334155; padding-bottom: 6px;
        }
        .tooltip-label {
            display: inline-block; background: #3b82f6; color: white;
            padding: 2px 8px; border-radius: 4px; margin: 2px;
            font-size: 11px;
        }
        .tooltip-text {
            margin-top: 8px; color: #cbd5e1; font-size: 12px;
        }
        
        /* Property Panel - Dark Theme */
        #property-panel {
            position: fixed; right: 0; top: 0; width: 350px; height: 100%;
            background: #1a1f2e; border-left: 2px solid #2d3748; box-shadow: -2px 0 20px rgba(0,0,0,0.5);
            overflow-y: auto; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            z-index: 1000; transform: translateX(100%); transition: transform 0.3s ease;
            color: #e2e8f0;
        }
        #property-panel.open { transform: translateX(0); }
        #property-panel h3 { margin-top:0; border-bottom:2px solid #3b82f6; padding-bottom:10px; color:#3b82f6; }
        #property-panel .section { margin:15px 0; }
        #property-panel .section-title { font-weight:bold; color:#94a3b8; margin-bottom:5px; font-size:13px; text-transform:uppercase; }
        #property-panel .property { background:#0f172a; padding:8px; margin:4px 0; border-radius:6px; font-size:13px; word-wrap:break-word; border:1px solid #334155; }
        #property-panel .property-key { font-weight:bold; color:#60a5fa; }
        #property-panel .label-badge { display:inline-block; background:#3b82f6; color:white; padding:3px 8px; border-radius:4px; margin:2px; font-size:11px; box-shadow:0 2px 4px rgba(59,130,246,0.3); }
        #property-panel .close-btn { position:absolute; top:10px; right:10px; background:#ef4444; color:white; border:none; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:14px; transition:all 0.2s; }
        #property-panel .close-btn:hover { background:#dc2626; box-shadow:0 4px 8px rgba(239,68,68,0.4); }
        #property-panel .vector-item { background:#0f172a; padding:8px; margin:6px 0; border-left:3px solid #10b981; border-radius:4px; }
        #property-panel .vector-type { font-size:10px; color:#94a3b8; text-transform:uppercase; margin-bottom:4px; }
        #property-panel .timestamp { color:#94a3b8; font-size:12px; font-style:italic; }
        #property-panel .neighbor-item { 
            background:#1e293b; padding:10px; margin:6px 0; border-radius:6px; 
            cursor:pointer; transition:all 0.2s; border-left: 4px solid;
            position: relative;
        }
        #property-panel .neighbor-item:hover { background:#334155; transform:translateX(-2px); }
        #property-panel .neighbor-name { font-weight:bold; color:#60a5fa; font-size: 13px; }
        #property-panel .neighbor-relationship { 
            font-size:11px; color:#94a3b8; margin-top:4px;
            background: #0f172a; padding: 4px 8px; border-radius: 4px;
            display: inline-block; margin-top: 6px;
        }
        #property-panel code { background:#0f172a; padding:2px 6px; border-radius:3px; color:#a78bfa; font-size:12px; }

        /* Settings Panel - Dark Theme */
        .settings-panel {
            position: fixed; left:0; top:0; width:280px; height:100%; background:#1a1f2e; border-right:2px solid #2d3748; padding:15px;
            overflow-y:auto; box-shadow:2px 0 20px rgba(0,0,0,0.5); font-family:-apple-system, BlinkMacSystemFont,'Segoe UI',sans-serif; z-index:1000;
            color:#e2e8f0; display: none;
        }
        .settings-panel h3 { margin-top:0; border-bottom:2px solid #3b82f6; padding-bottom:10px; color:#3b82f6; }
        .settings-panel label { display:block; margin-top:10px; font-weight:bold; font-size:12px; color:#cbd5e1; }
        .settings-panel input[type=range] { width:100%; accent-color:#3b82f6; }
        .settings-panel select { width:100%; padding:6px; background:#0f172a; color:#e2e8f0; border:1px solid #334155; border-radius:6px; cursor:pointer; margin-top:5px; font-size:12px; }
        .settings-toggle {
            position: fixed; top:10px; left:10px; z-index:2000;
            background:#3b82f6; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer;
            font-weight:600; transition:all 0.2s; box-shadow:0 4px 8px rgba(59,130,246,0.3);
            pointer-events: auto;
        }
        .settings-toggle:hover { background:#2563eb; box-shadow:0 6px 12px rgba(59,130,246,0.4); transform:translateY(-1px); }
        
        /* Edge Filters - Dark Theme */
        .filter-section { margin-top:20px; padding-top:15px; border-top:2px solid #334155; }
        .filter-item { display:flex; align-items:center; margin:8px 0; }
        .filter-item input[type=checkbox] { margin-right:8px; width:16px; height:16px; cursor:pointer; accent-color:#3b82f6; }
        .filter-item label { cursor:pointer; font-size:12px; font-weight:normal; color:#cbd5e1; }
        .filter-section button { width:100%; padding:8px; margin-top:5px; cursor:pointer; background:#3b82f6; color:white; border:none; border-radius:6px; font-weight:600; transition:all 0.2s; }
        .filter-section button:hover { background:#2563eb; box-shadow:0 4px 8px rgba(59,130,246,0.3); }
        .filter-options { margin:10px 0; padding:10px; background:#0f172a; border-radius:6px; border:1px solid #334155; }
        .filter-options label { display:flex; align-items:center; margin:6px 0; font-weight:normal; color:#cbd5e1; }
        .filter-options input[type=checkbox] { margin-right:8px; accent-color:#3b82f6; }
    </style>
</head>
<body>
    <!-- Settings Toggle Button -->
    <button class="settings-toggle" id="settings-toggle-btn">‚öôÔ∏è Settings</button>
    
    <!-- Search Bar -->
    <div class="search-container">
        <div class="search-input-row">
            <input type="text" id="search-input" placeholder="Search nodes...">
            <button id="search-btn">üîç</button>
        </div>
        <div class="search-results" id="search-results"></div>
    </div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" data-action="search">
            <span class="icon">üîç</span>
            <span>Search</span>
        </div>
        <div class="context-menu-item" data-action="enrich">
            <span class="icon">‚ú®</span>
            <span>Enrich (NLP Analysis)</span>
        </div>
        <div class="context-menu-item" data-action="hidden-relationships">
            <span class="icon">üîó</span>
            <span>Hidden Relationships</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="discover">
            <span class="icon">üß≠</span>
            <span>Discover</span>
        </div>
        <div class="context-menu-item" data-action="ideas">
            <span class="icon">üí°</span>
            <span>Generate Ideas</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="subgraph">
            <span class="icon">üó∫Ô∏è</span>
            <span>Extract Subgraph</span>
        </div>
        <div class="context-menu-item" data-action="ask-vera">
            <span class="icon">ü§ñ</span>
            <span>Ask Vera</span>
        </div>
    </div>
    
    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <h3>Graph Settings</h3>
        <label>Base Node Size: <span id="nodeSizeVal">40</span></label>
        <input type="range" min="10" max="100" value="40" id="nodeSize">
        <label>Edge Thickness: <span id="edgeWidthVal">4</span></label>
        <input type="range" min="1" max="10" value="4" id="edgeWidth">
        <label>Physics Strength: <span id="physicsVal">0.01</span></label>
        <input type="range" min="0.001" max="0.05" step="0.001" value="0.01" id="physics">
        
        <label>Node Style:</label>
        <select id="nodeStyle">
            <option value="dot">Circle (Default)</option>
            <option value="box">Rounded Rectangle</option>
            <option value="card">Card View (Rich)</option>
            <option value="ellipse">Ellipse</option>
            <option value="database">Database</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="triangle">Triangle</option>
            <option value="square">Square</option>
        </select>
        
        <button style="margin-top:10px;" id="reset-focus-btn">Reset View</button>
        <button style="margin-top:5px;" id="cluster-hubs-btn">Cluster Hubs</button>
        
        <div class="filter-section">
            <h3>Edge Filters</h3>
            <div class="filter-options">
                <label>
                    <input type="checkbox" id="cascade-hide">
                    Hide isolated nodes
                </label>
            </div>
            <div id="edge-filters">
                <div style="padding:10px; color:#94a3b8; font-size:12px;">Loading...</div>
            </div>
            <button id="select-all-filters-btn">Select All</button>
            <button id="deselect-all-filters-btn">Deselect All</button>
            <button id="refresh-filters-btn">Refresh Filters</button>
        </div>
    </div>

    <!-- Property Panel -->
    <div id="property-panel">
        <button class="close-btn" id="close-panel-btn">‚úï</button>
        <h3>Node Properties</h3>
        <div id="panel-content">
            <p style="text-align:center; color:#999;">Click a node to view details</p>
        </div>
    </div>

    <script>
    (function() {
        'use strict';
        
        window.GraphAddon = {
            vectorData: {},
            nodesData: {},
            focusedNodeId: null,
            allEdges: [],
            edgeTypes: new Set(),
            activeFilters: {},
            cascadeHideNodes: false,
            networkReady: false,
            contextMenuNode: null,
            
            init: function(vectorData) {
                console.log('GraphAddon initializing...');
                this.vectorData = vectorData || {};
                this.setupUIListeners();
                this.waitForNetwork();
            },
            
            setupUIListeners: function() {
                const self = this;
                
                const addListener = (id, event, handler) => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener(event, handler);
                };
                
                addListener('settings-toggle-btn', 'click', () => self.toggleSettings());
                addListener('close-panel-btn', 'click', () => self.closePanel());
                addListener('reset-focus-btn', 'click', () => self.resetFocus());
                addListener('cluster-hubs-btn', 'click', () => self.clusterHubs());
                addListener('select-all-filters-btn', 'click', () => self.toggleAllFilters(true));
                addListener('deselect-all-filters-btn', 'click', () => self.toggleAllFilters(false));
                addListener('refresh-filters-btn', 'click', () => self.initializeFilters());
                addListener('cascade-hide', 'change', () => self.toggleCascadeHide());
                addListener('nodeSize', 'input', () => self.updateSettings());
                addListener('edgeWidth', 'input', () => self.updateSettings());
                addListener('physics', 'input', () => self.updateSettings());
                addListener('nodeStyle', 'change', () => self.updateNodeStyle());
                addListener('search-btn', 'click', () => self.performSearch());
                addListener('search-input', 'keypress', (e) => {
                    if (e.key === 'Enter') self.performSearch();
                });
                
                // Context menu
                document.addEventListener('click', () => self.hideContextMenu());
                
                const contextMenu = document.getElementById('context-menu');
                contextMenu.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const item = e.target.closest('.context-menu-item');
                    if (item) {
                        const action = item.getAttribute('data-action');
                        self.handleContextMenuAction(action);
                    }
                });
            },
            
            waitForNetwork: function() {
                const self = this;
                if (typeof network !== 'undefined' && network.body) {
                    console.log('Network found, building node data...');
                    self.buildNodesData();
                    self.setupEventListeners();
                } else {
                    console.log('Waiting for network...');
                    setTimeout(() => self.waitForNetwork(), 500);
                }
            },
            
            buildNodesData: function() {
                try {
                    const nodes = network.body.data.nodes.get();
                    this.nodesData = {};
                    
                    nodes.forEach(node => {
                        let properties = {};
                        let labels = [];
                        
                        if (node.title) {
                            try {
                                const parsed = JSON.parse(node.title);
                                properties = parsed.properties || parsed;
                                labels = parsed.labels || [];
                            } catch (e) {
                                const titleStr = String(node.title);
                                properties = { raw_title: titleStr };
                            }
                        }
                        
                        const safeProperties = this.sanitizeProperties(properties);
                        
                        this.nodesData[node.id] = {
                            id: node.id,
                            labels: labels,
                            properties: safeProperties,
                            display_name: node.label || String(node.id),
                            color: node.color
                        };
                    });
                    
                    console.log(`Built data for ${Object.keys(this.nodesData).length} nodes`);
                } catch (e) {
                    console.error('Error building nodes data:', e);
                }
            },
            
            sanitizeProperties: function(properties) {
                if (!properties || typeof properties !== 'object') {
                    return {};
                }
                
                const sanitized = {};
                for (const [key, value] of Object.entries(properties)) {
                    try {
                        if (value === null || value === undefined) {
                            sanitized[key] = 'null';
                        } else if (value instanceof Date) {
                            sanitized[key] = value.toISOString();
                        } else if (typeof value === 'object') {
                            try {
                                sanitized[key] = JSON.stringify(value);
                            } catch (e) {
                                sanitized[key] = '[Complex Object]';
                            }
                        } else {
                            sanitized[key] = String(value);
                        }
                    } catch (e) {
                        console.warn(`Error sanitizing property ${key}:`, e);
                        sanitized[key] = '[Error rendering value]';
                    }
                }
                return sanitized;
            },
            
            createCardViewLabel: function(node) {
                const nodeData = this.nodesData[node.id];
                if (!nodeData) return node.label;
                
                const title = nodeData.display_name || node.id;
                const labels = nodeData.labels || [];
                const props = nodeData.properties || {};
                
                // Extract text/body/summary
                let bodyText = props.text || props.body || props.summary || props.description || props.content || '';
                if (bodyText.length > 100) {
                    bodyText = bodyText.substring(0, 100) + '...';
                }
                
                // Build plain text with line breaks for vis.js
                let label = title;
                
                if (labels.length > 0) {
                    label += '\n[' + labels.slice(0, 3).join(', ') + ']';
                }
                
                if (bodyText) {
                    label += '\n' + bodyText;
                }
                
                return label;
            },
            
            createEnhancedTooltip: function(node) {
                const nodeData = this.nodesData[node.id];
                if (!nodeData) return node.label || String(node.id);
                
                const title = nodeData.display_name || String(node.id);
                const labels = nodeData.labels || [];
                const props = nodeData.properties || {};
                
                let bodyText = props.text || props.body || props.summary || props.description || props.content || '';
                if (bodyText.length > 200) {
                    bodyText = bodyText.substring(0, 200) + '...';
                }
                
                // Build HTML for tooltip
                let html = '<div style="max-width:350px;">';
                html += `<div style="font-weight:bold; color:#000000; margin-bottom:8px; font-size:14px; border-bottom:1px solid #334155; padding-bottom:6px;">${this.escapeHtml(title)}</div>`;
                
                if (labels.length > 0) {
                    html += '<div style="margin-bottom:8px;">';
                    labels.slice(0, 3).forEach(label => {
                        html += `<span style="display:inline-block; background:#000000; color:white; padding:2px 8px; border-radius:4px; margin:2px; font-size:11px;">${this.escapeHtml(String(label))}</span>`;
                    });
                    html += '</div>';
                }
                
                if (bodyText) {
                    html += `<div style="margin-top:8px; color:#000000; font-size:12px; line-height:1.5;">${this.escapeHtml(bodyText)}</div>`;
                }
                
                html += '</div>';
                return html;
            },
            
            setupEventListeners: function() {
                const self = this;
                
                network.off("click");
                network.on("click", function(params) {
                    if (!self.networkReady) return;
                    
                    if (params.nodes.length > 0) {
                        self.focusOnNode(params.nodes[0]);
                    } else if (params.edges.length > 0) {
                        self.showEdgeDetails(params.edges[0]);
                    } else {
                        self.closePanel();
                    }
                });
                 
                // Right-click context menu
                network.on("oncontext", function(params) {
                    params.event.preventDefault();
                    
                    const nodeId = network.getNodeAt(params.pointer.DOM);
                    if (nodeId) {
                        self.contextMenuNode = nodeId;
                        self.showContextMenu(params.event.clientX, params.event.clientY);
                    }
                });
                
                network.once('stabilized', function() {
                    console.log('Network stabilized');
                    self.networkReady = true;
                    setTimeout(() => self.initializeFilters(), 1000);
                });
                
                setTimeout(function() {
                    if (!self.networkReady) {
                        self.networkReady = true;
                        self.initializeFilters();
                    }
                }, 5000);
            },
            
            showContextMenu: function(x, y) {
                const menu = document.getElementById('context-menu');
                menu.style.display = 'block';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
            },
            
            hideContextMenu: function() {
                const menu = document.getElementById('context-menu');
                menu.style.display = 'none';
            },
            
            handleContextMenuAction: function(action) {
                this.hideContextMenu();
                
                if (!this.contextMenuNode) return;
                
                const nodeData = this.nodesData[this.contextMenuNode];
                const nodeName = nodeData ? nodeData.display_name : this.contextMenuNode;
                
                switch(action) {
                    case 'search':
                        console.log('Search action for node:', nodeName);
                        alert(`Search functionality will be implemented for: ${nodeName}`);
                        break;
                    case 'enrich':
                        console.log('Enrich (NLP) action for node:', nodeName);
                        alert(`NLP Analysis will be performed on: ${nodeName}\n\nThis will analyze text content and extract:\n- Entities\n- Keywords\n- Sentiment\n- Topics`);
                        break;
                    case 'hidden-relationships':
                        console.log('Hidden relationships action for node:', nodeName);
                        alert(`Discovering hidden relationships for: ${nodeName}\n\nThis will analyze:\n- Indirect connections\n- Pattern-based relationships\n- Semantic similarities`);
                        break;
                    case 'discover':
                        console.log('Discover action for node:', nodeName);
                        alert(`Discovery mode for: ${nodeName}\n\nThis will explore:\n- Related concepts\n- Knowledge gaps\n- Expansion opportunities`);
                        break;
                    case 'ideas':
                        console.log('Generate ideas action for node:', nodeName);
                        alert(`Generating idea stubs for: ${nodeName}\n\nThis will create:\n- Related concepts\n- Questions to explore\n- Potential connections`);
                        break;
                    case 'subgraph':
                        this.extractSubgraph(this.contextMenuNode);
                        break;
                    case 'ask-vera':
                        console.log('Ask Vera action for node:', nodeName);
                        alert(`Ask Vera about: ${nodeName}\n\nYou can ask:\n- Questions about this node\n- Request analysis\n- Get recommendations`);
                        break;
                }
            },
            
            extractSubgraph: function(centerNodeId) {
                console.log('Extracting subgraph for node:', centerNodeId);
                
                try {
                    // Get all connected nodes (1-hop neighborhood)
                    const connectedNodes = network.getConnectedNodes(centerNodeId);
                    const subgraphNodes = [centerNodeId, ...connectedNodes];
                    
                    // Get all edges between these nodes
                    const allEdges = network.body.data.edges.get();
                    const subgraphEdges = allEdges.filter(edge => {
                        return subgraphNodes.includes(edge.from) && subgraphNodes.includes(edge.to);
                    });
                    
                    // Hide all nodes except subgraph
                    const allNodeIds = Object.keys(this.nodesData);
                    const nodeUpdates = allNodeIds.map(nodeId => ({
                        id: nodeId,
                        hidden: !subgraphNodes.includes(nodeId)
                    }));
                    
                    network.body.data.nodes.update(nodeUpdates);
                    
                    // Hide all edges except subgraph
                    const edgeUpdates = allEdges.map(edge => ({
                        id: edge.id,
                        hidden: !subgraphEdges.some(e => e.id === edge.id)
                    }));
                    
                    network.body.data.edges.update(edgeUpdates);
                    
                    // Fit view to subgraph
                    setTimeout(() => {
                        network.fit({
                            nodes: subgraphNodes,
                            animation: { duration: 1000, easingFunction: 'easeInOutQuad' }
                        });
                    }, 100);
                    
                    // Show info
                    const nodeData = this.nodesData[centerNodeId];
                    const nodeName = nodeData ? nodeData.display_name : centerNodeId;
                    
                    console.log(`Subgraph extracted: ${subgraphNodes.length} nodes, ${subgraphEdges.length} edges`);
                    
                    // Add notification in panel
                    const panel = document.getElementById('property-panel');
                    const content = document.getElementById('panel-content');
                    
                    content.innerHTML = `
                        <div style="text-align:center; padding:20px;">
                            <div style="font-size:24px; margin-bottom:10px;">üó∫Ô∏è</div>
                            <div style="font-weight:bold; color:#60a5fa; margin-bottom:10px;">Subgraph Extracted</div>
                            <div style="color:#cbd5e1; font-size:13px; margin-bottom:15px;">
                                Centered on: <strong>${this.escapeHtml(nodeName)}</strong>
                            </div>
                            <div style="background:#0f172a; padding:12px; border-radius:6px; margin-bottom:15px;">
                                <div style="color:#94a3b8; font-size:12px;">
                                    <div>Nodes: <strong style="color:#60a5fa;">${subgraphNodes.length}</strong></div>
                                    <div style="margin-top:4px;">Edges: <strong style="color:#60a5fa;">${subgraphEdges.length}</strong></div>
                                </div>
                            </div>
                            <button onclick="window.GraphAddon.resetSubgraph()" style="
                                background:#3b82f6; color:white; border:none; padding:8px 16px;
                                border-radius:6px; cursor:pointer; font-weight:600; font-size:13px;
                            ">Show Full Graph</button>
                        </div>
                    `;
                    panel.classList.add('open');
                    
                } catch (e) {
                    console.error('Error extracting subgraph:', e);
                    alert('Error extracting subgraph. See console for details.');
                }
            },
            
            resetSubgraph: function() {
                console.log('Resetting to full graph');
                
                // Show all nodes and edges
                const allNodeIds = Object.keys(this.nodesData);
                const nodeUpdates = allNodeIds.map(nodeId => ({
                    id: nodeId,
                    hidden: false
                }));
                network.body.data.nodes.update(nodeUpdates);
                
                const allEdges = network.body.data.edges.get();
                const edgeUpdates = allEdges.map(edge => ({
                    id: edge.id,
                    hidden: false
                }));
                network.body.data.edges.update(edgeUpdates);
                
                // Reapply filters
                this.applyFilters();
                
                // Reset view
                this.resetFocus();
                
                // Close panel
                this.closePanel();
            },
            
            performSearch: function() {
                const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
                const resultsContainer = document.getElementById('search-results');
                
                if (!searchTerm) {
                    resultsContainer.style.display = 'none';
                    resultsContainer.innerHTML = '';
                    return;
                }
                
                const matchingNodes = [];
                
                for (const [nodeId, nodeData] of Object.entries(this.nodesData)) {
                    const searchableText = [
                        nodeData.display_name,
                        ...(nodeData.labels || []),
                        ...Object.values(nodeData.properties || {})
                    ].join(' ').toLowerCase();
                    
                    if (searchableText.includes(searchTerm)) {
                        matchingNodes.push({
                            id: nodeId,
                            data: nodeData
                        });
                    }
                }
                
                if (matchingNodes.length === 0) {
                    resultsContainer.innerHTML = '<div style="padding:8px; color:#94a3b8; font-size:12px; text-align:center;">No results found</div>';
                    resultsContainer.style.display = 'block';
                    return;
                }
                
                console.log(`Found ${matchingNodes.length} matching nodes`);
                
                // Build results list
                let html = '';
                matchingNodes.slice(0, 20).forEach(match => {
                    const labels = match.data.labels && match.data.labels.length > 0 
                        ? match.data.labels.slice(0, 2).join(', ') 
                        : '';
                    html += `
                        <div class="search-result-item" data-node-id="${this.escapeHtml(String(match.id))}">
                            <div class="search-result-name">${this.escapeHtml(match.data.display_name)}</div>
                            ${labels ? `<div class="search-result-labels">${this.escapeHtml(labels)}</div>` : ''}
                        </div>
                    `;
                });
                
                if (matchingNodes.length > 20) {
                    html += `<div style="padding:8px; color:#94a3b8; font-size:11px; text-align:center;">Showing first 20 of ${matchingNodes.length} results</div>`;
                }
                
                resultsContainer.innerHTML = html;
                resultsContainer.style.display = 'block';
                
                // Add click handlers
                const self = this;
                resultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const nodeId = this.getAttribute('data-node-id');
                        self.focusOnNode(nodeId);
                    });
                });
                
                // Highlight all matching nodes
                const matchingIds = matchingNodes.map(m => m.id);
                network.selectNodes(matchingIds);
                
                // // Focus on the first result
                // if (matchingNodes.length > 0) {
                //     network.fit({
                //         nodes: matchingIds.slice(0, 50),
                //         animation: { duration: 1000, easingFunction: 'easeInOutQuad' }
                //     });
                    
                //     // Auto-focus on first result
                //     this.focusOnNode(matchingNodes[0].id);
                // }
            },
            
            initializeFilters: function() {
                if (!network.body || !network.body.data) {
                    setTimeout(() => this.initializeFilters(), 1000);
                    return;
                }
                
                const edges = network.body.data.edges.get();
                if (edges.length === 0) {
                    setTimeout(() => this.initializeFilters(), 2000);
                    return;
                }
                
                this.allEdges = edges;
                const previousFilters = {...this.activeFilters};
                this.edgeTypes.clear();
                
                edges.forEach(edge => {
                    const edgeType = edge.label || edge.type || edge.title || 'unlabeled';
                    this.edgeTypes.add(edgeType);
                });
                
                const filterContainer = document.getElementById('edge-filters');
                if (!filterContainer) return;
                
                filterContainer.innerHTML = '';
                
                this.edgeTypes.forEach(type => {
                    this.activeFilters[type] = previousFilters.hasOwnProperty(type) ? previousFilters[type] : true;
                    
                    const div = document.createElement('div');
                    div.className = 'filter-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `filter-${type}`;
                    checkbox.checked = this.activeFilters[type];
                    checkbox.addEventListener('change', () => this.applyFilters());
                    
                    const label = document.createElement('label');
                    label.setAttribute('for', `filter-${type}`);
                    label.textContent = type;
                    
                    div.appendChild(checkbox);
                    div.appendChild(label);
                    filterContainer.appendChild(div);
                });
                
                this.applyFilters();
            },
            
            applyFilters: function() {
                if (!this.networkReady) return;
                
                try {
                    this.edgeTypes.forEach(type => {
                        const checkbox = document.getElementById(`filter-${type}`);
                        if (checkbox) {
                            this.activeFilters[type] = checkbox.checked;
                        }
                    });
                    
                    const filteredEdges = this.allEdges.filter(edge => {
                        const edgeType = edge.label || edge.type || edge.title || 'unlabeled';
                        return this.activeFilters[edgeType] !== false;
                    });
                    
                    network.body.data.edges.clear();
                    network.body.data.edges.add(filteredEdges);
                    
                    if (this.cascadeHideNodes) {
                        const connectedNodeIds = new Set();
                        filteredEdges.forEach(edge => {
                            connectedNodeIds.add(edge.from);
                            connectedNodeIds.add(edge.to);
                        });
                        
                        const nodeUpdates = Object.keys(this.nodesData).map(nodeId => ({
                            id: nodeId,
                            hidden: !connectedNodeIds.has(nodeId)
                        }));
                        
                        network.body.data.nodes.update(nodeUpdates);
                    } else {
                        const nodeUpdates = Object.keys(this.nodesData).map(nodeId => ({
                            id: nodeId,
                            hidden: false
                        }));
                        
                        network.body.data.nodes.update(nodeUpdates);
                    }
                } catch (e) {
                    console.error('Error applying filters:', e);
                }
            },
            
            toggleAllFilters: function(state) {
                this.edgeTypes.forEach(type => {
                    const checkbox = document.getElementById(`filter-${type}`);
                    if (checkbox) {
                        checkbox.checked = state;
                        this.activeFilters[type] = state;
                    }
                });
                this.applyFilters();
            },
            
            toggleCascadeHide: function() {
                this.cascadeHideNodes = document.getElementById('cascade-hide').checked;
                this.applyFilters();
            },
            
            focusOnNode: function(nodeId) {
                this.showNodeDetails(nodeId, true);
                network.selectNodes([nodeId]);
            },
            
            showNodeDetails: function(nodeId, focusViewport) {
                const panel = document.getElementById('property-panel');
                const content = document.getElementById('panel-content');
                
                try {
                    if (!this.nodesData[nodeId]) {
                        content.innerHTML = '<p style="color:#ef4444;">Node data not found</p>';
                        panel.classList.add('open');
                        return;
                    }
                    
                    const node = this.nodesData[nodeId];
                    
                    let html = `
                        <div class="section">
                            <div class="section-title">Node ID</div>
                            <div class="property"><code>${this.escapeHtml(String(node.id))}</code></div>
                        </div>
                        <div class="section">
                            <div class="section-title">Labels</div>
                            <div>${(node.labels || []).map(l => `<span class="label-badge">${this.escapeHtml(String(l))}</span>`).join('')}</div>
                        </div>
                        <div class="section">
                            <div class="section-title">Display Name</div>
                            <div class="property">${this.escapeHtml(node.display_name || String(node.id))}</div>
                        </div>
                        <div class="section">
                            <div class="section-title">Properties</div>
                    `;
                    
                    const props = node.properties || {};
                    const propEntries = Object.entries(props);
                    const maxPropsToShow = 20;
                    const propsToShow = propEntries.slice(0, maxPropsToShow);
                    const hasMoreProps = propEntries.length > maxPropsToShow;
                    
                    propsToShow.forEach(([key, value]) => {
                        const displayValue = typeof value === 'string' && value.length > 200 
                            ? this.escapeHtml(value.substring(0, 200)) + '...' 
                            : this.escapeHtml(String(value));
                        html += `<div class="property"><span class="property-key">${this.escapeHtml(String(key))}:</span> ${displayValue}</div>`;
                    });
                    
                    if (hasMoreProps) {
                        html += `<div style="text-align:center; font-style:italic; color:#94a3b8; margin-top:8px;">Showing first ${maxPropsToShow} of ${propEntries.length} properties</div>`;
                    }
                    
                    html += `</div><div class="section"><div class="section-title">Neighbors</div>`;
                    const neighbors = this.getNeighbors(nodeId);
                    const maxNeighbors = 50;
                    const neighborsToShow = neighbors.slice(0, maxNeighbors);
                    const hasMoreNeighbors = neighbors.length > maxNeighbors;
                    
                    if (neighborsToShow.length > 0) {
                        neighborsToShow.forEach(neighbor => {
                            const borderColor = neighbor.color || '#3b82f6';
                            html += `
                                <div class="neighbor-item" data-neighbor-id="${this.escapeHtml(String(neighbor.id))}" style="border-left-color: ${borderColor};">
                                    <div class="neighbor-name">${this.escapeHtml(neighbor.name)}</div>
                                    <div class="neighbor-relationship">${this.escapeHtml(neighbor.relationship)}</div>
                                </div>
                            `;
                        });
                        
                        if (hasMoreNeighbors) {
                            html += `<div style="text-align:center; font-style:italic; color:#94a3b8; margin-top:8px;">Showing first ${maxNeighbors} of ${neighbors.length} neighbors</div>`;
                        }
                    } else {
                        html += '<div style="text-align:center; font-style:italic; color:#64748b;">No neighbors</div>';
                    }
                    
                    html += `</div><div class="section"><div class="section-title">Vector Content</div>${this.renderVectorContent(nodeId)}</div>`;
                    
                    content.innerHTML = html;
                    panel.classList.add('open');
                    
                    const neighborItems = content.querySelectorAll('.neighbor-item[data-neighbor-id]');
                    neighborItems.forEach(item => {
                        const neighborId = item.getAttribute('data-neighbor-id');
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.focusOnNode(neighborId);
                        });
                    });
                    
                    if (focusViewport) {
                        try {
                            const connectedNodes = network.getConnectedNodes(nodeId);
                            const nodesToFit = [nodeId, ...connectedNodes.slice(0, 100)];
                            network.fit({
                                nodes: nodesToFit,
                                animation: { duration: 1000, easingFunction: 'easeInOutQuad' }
                            });
                        } catch (e) {
                            console.warn('Error fitting viewport:', e);
                        }
                    }
                } catch (e) {
                    console.error('Error showing node details:', e);
                    content.innerHTML = `<p style="color:#ef4444;">Error displaying node: ${e.message}</p>`;
                    panel.classList.add('open');
                }
            },
            
            showEdgeDetails: function(edgeId) {
                const panel = document.getElementById('property-panel');
                const content = document.getElementById('panel-content');
                
                try {
                    const edge = network.body.data.edges.get(edgeId);
                    if (!edge) {
                        content.innerHTML = '<p style="color:#ef4444;">Edge data not found</p>';
                        panel.classList.add('open');
                        return;
                    }
                    
                    const fromNode = this.nodesData[edge.from];
                    const toNode = this.nodesData[edge.to];
                    const relationship = edge.label || edge.type || 'Connection';
                    
                    let html = `
                        <div class="section">
                            <div class="section-title">Edge</div>
                            <div class="property"><code>${this.escapeHtml(String(edge.id || 'N/A'))}</code></div>
                        </div>
                        <div class="section">
                            <div class="section-title">Relationship</div>
                            <div class="property">${this.escapeHtml(String(relationship))}</div>
                        </div>
                        <div class="section">
                            <div class="section-title">From Node</div>
                            <div class="neighbor-item" data-node-id="${this.escapeHtml(String(edge.from))}" style="border-left-color: ${fromNode?.color || '#3b82f6'};">
                                <div class="neighbor-name">${this.escapeHtml(fromNode ? fromNode.display_name : String(edge.from))}</div>
                                <div class="neighbor-relationship">Click to view details</div>
                            </div>
                        </div>
                        <div class="section">
                            <div class="section-title">To Node</div>
                            <div class="neighbor-item" data-node-id="${this.escapeHtml(String(edge.to))}" style="border-left-color: ${toNode?.color || '#3b82f6'};">
                                <div class="neighbor-name">${this.escapeHtml(toNode ? toNode.display_name : String(edge.to))}</div>
                                <div class="neighbor-relationship">Click to view details</div>
                            </div>
                        </div>
                    `;
                    
                    content.innerHTML = html;
                    panel.classList.add('open');
                    
                    const edgeNeighbors = content.querySelectorAll('.neighbor-item[data-node-id]');
                    edgeNeighbors.forEach(item => {
                        const nodeId = item.getAttribute('data-node-id');
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.focusOnNode(nodeId);
                        });
                    });
                } catch (e) {
                    console.error('Error showing edge details:', e);
                    content.innerHTML = `<p style="color:#ef4444;">Error displaying edge: ${e.message}</p>`;
                    panel.classList.add('open');
                }
            },
            
            getNeighbors: function(nodeId) {
                const neighbors = [];
                try {
                    const connectedEdges = network.getConnectedEdges(nodeId);
                    
                    connectedEdges.forEach(edgeId => {
                        const edge = network.body.data.edges.get(edgeId);
                        if (!edge) return;
                        
                        const neighborId = edge.from === nodeId ? edge.to : edge.from;
                        const neighborNode = this.nodesData[neighborId];
                        
                        if (neighborNode) {
                            const edgeLabel = edge.label || edge.type || 'connected';
                            const direction = edge.from === nodeId ? '‚Üí' : '‚Üê';
                            neighbors.push({
                                id: neighborId,
                                name: neighborNode.display_name || neighborId,
                                relationship: `${direction} ${edgeLabel}`,
                                color: neighborNode.color
                            });
                        }
                    });
                } catch (e) {
                    console.error('Error getting neighbors:', e);
                }
                
                return neighbors;
            },
            
            renderVectorContent: function(nodeId) {
                try {
                    if (!this.vectorData || !this.vectorData[nodeId]) {
                        return '<div style="text-align:center; font-style:italic; color:#64748b;">No vector content</div>';
                    }
                    
                    let vectorItems = this.vectorData[nodeId];
                    
                    if (!Array.isArray(vectorItems)) {
                        if (typeof vectorItems === 'object') {
                            vectorItems = [vectorItems];
                        } else if (typeof vectorItems === 'string') {
                            vectorItems = [{type: 'content', content: vectorItems}];
                        } else {
                            return '<div style="text-align:center; font-style:italic; color:#64748b;">Invalid vector data format</div>';
                        }
                    }
                    
                    if (vectorItems.length === 0) {
                        return '<div style="text-align:center; font-style:italic; color:#64748b;">No vector content</div>';
                    }
                    
                    const itemsToShow = vectorItems.slice(0, 50);
                    const hasMore = vectorItems.length > 50;
                    
                    let html = '';
                    itemsToShow.forEach(item => {
                        let content = '';
                        let type = 'content';
                        
                        if (typeof item === 'string') {
                            content = item;
                        } else if (typeof item === 'object' && item !== null) {
                            content = item.content || item.text || JSON.stringify(item);
                            type = item.type || 'content';
                        } else {
                            content = String(item);
                        }
                        
                        if (content.length > 500) {
                            content = content.substring(0, 500) + '...';
                        }
                        
                        const typeLabel = type === 'file_chunk' ? 'üìÑ File Chunk' :
                                         type === 'collection_doc' ? 'üìö Collection Doc' :
                                         type === 'semantic_match' ? 'üîç Semantic Match' :
                                         'üìù Content';
                        
                        html += `
                            <div class="vector-item">
                                <div class="vector-type">${typeLabel}</div>
                                <div style="font-size:12px;">${this.escapeHtml(content)}</div>
                            </div>
                        `;
                    });
                    
                    if (hasMore) {
                        html += `<div style="text-align:center; font-style:italic; color:#94a3b8; margin-top:10px;">Showing first 50 of ${vectorItems.length} items</div>`;
                    }
                    
                    return html;
                } catch (e) {
                    console.error('Error rendering vector content:', e);
                    return '<div style="text-align:center; font-style:italic; color:#ef4444;">Error rendering vector content</div>';
                }
            },
            
            escapeHtml: function(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            adjustBrightness: function(color, percent) {
                // Simple brightness adjustment for hex colors
                if (!color || !color.startsWith('#')) return color;
                
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                
                return '#' + (0x1000000 + 
                    (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
                    (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
                    (B < 255 ? (B < 1 ? 0 : B) : 255))
                    .toString(16).slice(1);
            },
            
            toggleSettings: function() {
                const panel = document.getElementById('settings-panel');
                if (panel) {
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                }
            },
            
            closePanel: function() {
                const panel = document.getElementById('property-panel');
                if (panel) panel.classList.remove('open');
            },
            
            resetFocus: function() {
                if (!this.networkReady) return;
                try {
                    network.unselectAll();
                    network.fit({animation: true});
                    this.focusedNodeId = null;
                } catch (e) {
                    console.error('Error resetting focus:', e);
                }
            },
            
            clusterHubs: function() {
                if (!this.networkReady) return;
                try {
                    network.clusterByHubsize({threshold: 12});
                } catch(e) {
                    console.log('Clustering error:', e);
                }
            },
            
            updateSettings: function() {
                if (!this.networkReady) return;
                
                try {
                    const baseSize = parseInt(document.getElementById('nodeSize').value);
                    const edgeWidth = parseInt(document.getElementById('edgeWidth').value);
                    const physicsStrength = parseFloat(document.getElementById('physics').value);
                    
                    document.getElementById('nodeSizeVal').innerText = baseSize;
                    document.getElementById('edgeWidthVal').innerText = edgeWidth;
                    document.getElementById('physicsVal').innerText = physicsStrength.toFixed(3);
                    
                    const nodeUpdates = [];
                    network.body.data.nodes.forEach(node => {
                        nodeUpdates.push({id: node.id, size: baseSize});
                    });
                    network.body.data.nodes.update(nodeUpdates);
                    
                    const edgeUpdates = [];
                    network.body.data.edges.forEach(edge => {
                        edgeUpdates.push({id: edge.id, width: edgeWidth});
                    });
                    network.body.data.edges.update(edgeUpdates);
                    
                    network.setOptions({
                        physics: {
                            barnesHut: { springConstant: physicsStrength }
                        }
                    });
                } catch (e) {
                    console.error('Error updating settings:', e);
                }
            },
            
            updateNodeStyle: function() {
                if (!this.networkReady) return;
                
                try {
                    const style = document.getElementById('nodeStyle').value;
                    
                    const nodeUpdates = [];
                    network.body.data.nodes.forEach(node => {
                        const updateData = {
                            id: node.id
                        };
                        
                        if (style === 'card') {
                            // Card view with rich content
                            const nodeColor = node.color || '#3b82f6';
                            updateData.shape = 'box';
                            updateData.label = this.createCardViewLabel(node);
                            updateData.font = {
                                multi: true,
                                color: '#000000',
                                size: 12,
                                face: 'arial',
                                align: 'left',
                                bold: { color: '#000000', size: 14 }
                            };
                            updateData.widthConstraint = {
                                minimum: 180,
                                maximum: 280
                            };
                            updateData.heightConstraint = {
                                minimum: 60
                            };
                            updateData.margin = 12;
                            updateData.shapeProperties = {
                                borderRadius: 6
                            };
                            // Preserve original colors
                            if (typeof nodeColor === 'string') {
                                updateData.color = {
                                    background: nodeColor,
                                    border: this.adjustBrightness(nodeColor, 20),
                                    highlight: {
                                        background: this.adjustBrightness(nodeColor, -10),
                                        border: this.adjustBrightness(nodeColor, 40)
                                    },
                                    hover: {
                                        background: this.adjustBrightness(nodeColor, -5),
                                        border: this.adjustBrightness(nodeColor, 30)
                                    }
                                };
                            } else if (typeof nodeColor === 'object') {
                                updateData.color = nodeColor;
                            }
                            updateData.title = this.createEnhancedTooltip(node);
                        } else if (style === 'box') {
                            const nodeColor = node.color;
                            updateData.shape = 'box';
                            updateData.font = {
                                color: '#000000',
                                size: 14,
                                face: 'arial'
                            };
                            updateData.widthConstraint = {
                                minimum: 80,
                                maximum: 200
                            };
                            updateData.heightConstraint = {
                                minimum: 40
                            };
                            // Preserve original colors
                            if (nodeColor) {
                                updateData.color = nodeColor;
                            }
                            updateData.title = this.createEnhancedTooltip(node);
                        } else {
                            const nodeColor = node.color;
                            updateData.shape = style;
                            updateData.font = {
                                color: '#ffffff',
                                size: 14
                            };
                            // Preserve original colors
                            if (nodeColor) {
                                updateData.color = nodeColor;
                            }
                            updateData.title = this.createEnhancedTooltip(node);
                        }
                        
                        nodeUpdates.push(updateData);
                    });
                    
                    network.body.data.nodes.update(nodeUpdates);
                    network.redraw();
                } catch (e) {
                    console.error('Error updating node style:', e);
                }
            }
        };
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                GraphAddon.init({});
            });
        } else {
            GraphAddon.init({});
        }
    })();
    </script>
</body>
</html>